# 补充测试

理论上昇腾端在计算的时候，其处理时间与数据集规模无关，与数据稠密度有关。也就是说顶点数目确定后，NPU的执行时间就已经确定，不会随着顶点平均度数的提高而提高。但是之前测试发现，NPU执行时间还是有波动。分析了一下原因：NPU端代码在生成矩阵的时候做了一个自动去重，把非零点筛除了，所以每次生成的矩阵规模<=理论规模。在对代码修改后，重新进行了补充测试：



# pagerank测试



# 图重排序测试

之前仅采用“**顶点度数**”一项标准，进行子图划分。发现排序后子图的稠密度并没有显著提升。下面是采用新的图重排序的算法的测试结果。后面又尝试了基于图划分和基于图聚类的方法来提取一个稠密子图。

## 算法步骤：

1. 读取原始数据集文件，并创建一个有向图对象。
2. 为了去除重复的边，使用一个集合来存储边的信息。
3. 遍历原始数据集文件的每一行，将起始点和终点解析为整数，并将边的信息添加到集合中。
4. 将集合中的边添加到图对象中。
5. 打印原始图数据集的信息，包括顶点数、边数和平均度数。
6. 根据给定的方法进行稠密子图划分：
   - 如果方法是'partition'（图划分方式）：
     - 使用弱连通组件算法找到原始图中的所有连通分量。
     - 计算每个连通分量的平均度数。
     - 按照平均度数从高到低对连通分量进行排序。
     - 选择最稠密的连通分量，使得总顶点数大于等于目标顶点数。
     - 构建最终的稠密子图，包含选定的连通分量中的顶点及其之间的边。
   - 如果方法是'clustering'（图聚类方式）：
     - 将有向图转换为无向图。
     - 使用图聚类算法计算每个节点的聚类系数。
     - 根据聚类系数对节点进行排序。
     - 选择排名靠前的节点作为稠密子图的顶点。
     - 构建最终的稠密子图，包含选定的顶点及其之间的边。
   - 如果方法选择无效，则打印错误消息并返回。
7. 打印稠密子图数据集的信息，包括顶点数、边数和平均度数。
8. 将稠密子图输出到文件中。

## 算法原理：

该算法的目标是从给定的图数据集中提取出一个稠密子图。根据给定的方法选择，算法有两种不同的实现方式。

1. 图划分方式（method='partition'）：
   - 首先，使用弱连通组件算法找到原始图中的所有连通分量。
   - 然后，计算每个连通分量的平均度数，通过计算每个连通分量的边数与顶点数之比的两倍来得到平均度数。
   - 接下来，按照平均度数从高到低对连通分量进行排序。
   - 选择最稠密的连通分量，并确保选定的连通分量的总顶点数小于等于目标顶点数。
   - 最后，构建稠密子图，包含选定连通分量中的顶点及其之间的边。
2. 图聚类方式（method='clustering'）：
   - 首先，将有向图转换为无向图，以便应用图聚类算法。
   - 然后，使用图聚类算法计算每个节点的聚类系数，聚类系数表示节点在其邻居节点中形成三角形的概率。
   - 接下来，根据聚类系数对节点进行排序，按照聚类系数从高到低进行排序。
   - 选择排名靠前的节点作为稠密子图的顶点。
   - 最后，构建稠密子图，包含选定的顶点及其之间的边。

无论使用哪种方式，算法最后会输出稠密子图的信息，并将稠密子图保存到指定的输出文件中。

## 实验结论

异构计算的方式下，子图规模过小的话，矩阵运算的性能增益不足以弥补，信息传输的开销。所以子图划分的规模是根据NPU上限定的40000。但是实验发现，两种方式划分得到的稠密子图，其平均度数均小于原始图的平均度数，没有明显增益。

顶点数: 81306
边数: 1768149
平均度数: 43.49369050254594

稠密子图数据集信息:
顶点数: 40000
边数: 441542
平均度数: 22.0771

